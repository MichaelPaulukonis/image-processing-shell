{
  "renamer": {
    "tasks": [
      {
        "id": "1",
        "title": "Project Setup and Configuration Management",
        "description": "Initialize the Flask application structure, set up configuration management, and establish the required directory structure for the application.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Create the Flask application with the following components:\n1. Initialize a Flask project using Flask 2.3.3\n2. Set up project directory structure as specified in Appendix B\n3. Create configuration management module to handle:\n   - Reading/writing JSON configuration files\n   - Creating necessary directories (~/.image-tagger-renamer/)\n   - Managing user preferences\n   - Setting up logging with the Python logging module\n4. Implement configuration file templates for config.json and tags.json\n5. Create requirements.txt with dependencies:\n   ```\n   Flask==2.3.3\n   Pillow==10.1.0\n   Werkzeug==2.3.7\n   ```\n6. Add default tag library with starter tags\n7. Set up error handling framework for consistent error reporting\n8. Implement environment detection for path handling across platforms using pathlib\n9. Create app.py entry point with command line arguments for folder path",
        "testStrategy": "1. Verify application initializes without errors\n2. Confirm configuration directory is created in user's home folder\n3. Test reading/writing of configuration files\n4. Verify log file creation and format\n5. Test default tag library initialization\n6. Test path handling on different operating systems (Windows/macOS/Linux)\n7. Verify command line arguments are properly parsed",
        "subtasks": [],
        "updatedAt": "2025-11-19T16:57:21.843Z"
      },
      {
        "id": "2",
        "title": "File System Operations and Image Processing",
        "description": "Implement core file system operations including directory scanning, image detection, and file renaming functionality.",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "Develop file_manager.py module with the following features:\n1. Directory scanning with support for JPG, PNG, and JP2 formats\n2. Atomic file rename operations with error handling\n3. Duplicate filename detection and automatic numbering (000, 001, etc.)\n4. File extension preservation\n5. Use pathlib for cross-platform path handling\n6. Implement safe file operations with try-except blocks\n7. Create filename generation logic based on prefix + alphabetically sorted tags + suffix + numbering\n8. Format: [prefix]_[tag1]_[tag2]_[tagN]_[suffix]_[number].ext\n9. Support for batch operations with progress tracking\n10. Handle file permission errors gracefully\n\nImplementation details:\n```python\nfrom pathlib import Path\nimport shutil\nimport os\n\ndef scan_directory(dir_path):\n    \"\"\"Scan directory for supported image files\"\"\"\n    supported_extensions = [\".jpg\", \".jpeg\", \".png\", \".jp2\"]\n    dir_path = Path(dir_path).expanduser().resolve()\n    return sorted([f for f in dir_path.iterdir() \n                   if f.is_file() and f.suffix.lower() in supported_extensions])\n\ndef generate_filename(prefix, tags, suffix, extension, counter=0):\n    \"\"\"Generate filename with alphabetically sorted tags\"\"\"\n    # Sort tags alphabetically\n    sorted_tags = sorted(tags)\n    \n    # Build filename parts\n    parts = []\n    if prefix:\n        parts.append(prefix)\n    parts.extend(sorted_tags)\n    if suffix:\n        parts.append(suffix)\n    \n    # Add counter and extension\n    filename = \"_\".join(parts)\n    if counter > 0:\n        filename += f\"_{counter:03d}\"\n    else:\n        filename += \"_000\"\n    \n    return f\"{filename}{extension}\"\n\ndef rename_file(src_path, dest_dir, prefix, tags, suffix, counter=0):\n    \"\"\"Rename a file with error handling\"\"\"\n    try:\n        src_path = Path(src_path)\n        dest_dir = Path(dest_dir)\n        extension = src_path.suffix\n        \n        new_name = generate_filename(prefix, tags, suffix, extension, counter)\n        dest_path = dest_dir / new_name\n        \n        # Check for duplicates and increment counter if needed\n        while dest_path.exists():\n            counter += 1\n            new_name = generate_filename(prefix, tags, suffix, extension, counter)\n            dest_path = dest_dir / new_name\n        \n        # Rename the file (atomic operation)\n        shutil.move(src_path, dest_path)\n        return new_name, None\n    except PermissionError:\n        return None, \"Permission denied\"\n    except Exception as e:\n        return None, str(e)\n```",
        "testStrategy": "1. Test directory scanning with various file types\n2. Verify correct identification of supported image formats\n3. Test filename generation with various combinations of prefix, tags, and suffix\n4. Verify tags are sorted alphabetically in generated filenames\n5. Test duplicate handling with sequential numbering\n6. Verify error handling for permission issues\n7. Test batch rename operations with large file sets\n8. Verify atomicity of file operations (no partial renames)\n9. Test with special characters in filenames and paths",
        "subtasks": []
      },
      {
        "id": "3",
        "title": "Thumbnail Generation and Caching System",
        "description": "Implement an efficient thumbnail generation system with disk caching to support quick loading of large image collections.",
        "status": "pending",
        "dependencies": [
          "1",
          "2"
        ],
        "priority": "high",
        "details": "Create thumbnail management module with the following features:\n1. Generate thumbnails at 150x150px size while preserving aspect ratio\n2. Implement disk-based caching system in ~/.image-tagger-renamer/cache/thumbnails/\n3. Cache invalidation based on file modification time\n4. Asynchronous thumbnail generation for better UI responsiveness\n5. Support all required image formats (JPG, PNG, JP2/JPEG2000)\n6. Handle errors for corrupted or unsupported images\n\nImplementation details:\n```python\nfrom PIL import Image, ImageOps\nimport hashlib\nfrom pathlib import Path\nimport os\nimport time\n\ndef get_cache_path(image_path, thumbnail_size=150):\n    \"\"\"Generate a unique cache path based on the image path and modification time\"\"\"\n    image_path = Path(image_path)\n    stats = image_path.stat()\n    # Create a hash based on path and modification time to avoid conflicts\n    hash_input = f\"{image_path}:{stats.st_mtime}:{thumbnail_size}\"\n    filename_hash = hashlib.md5(hash_input.encode()).hexdigest()\n    \n    cache_dir = Path(os.path.expanduser(\"~/.image-tagger-renamer/cache/thumbnails/\"))\n    cache_dir.mkdir(parents=True, exist_ok=True)\n    \n    return cache_dir / f\"{filename_hash}.jpg\"\n\ndef generate_thumbnail(image_path, thumbnail_size=150):\n    \"\"\"Generate a thumbnail for an image with caching\"\"\"\n    image_path = Path(image_path)\n    cache_path = get_cache_path(image_path, thumbnail_size)\n    \n    # If cached thumbnail exists and is up to date, use it\n    if cache_path.exists():\n        return str(cache_path)\n    \n    try:\n        # Open image and handle EXIF orientation\n        with Image.open(image_path) as img:\n            # Handle image orientation\n            img = ImageOps.exif_transpose(img)\n            \n            # Create thumbnail\n            img.thumbnail((thumbnail_size, thumbnail_size))\n            \n            # Save to cache with high quality\n            img.save(cache_path, \"JPEG\", quality=90)\n            return str(cache_path)\n    except Exception as e:\n        # For unsupported formats or corrupted images, generate placeholder\n        create_error_thumbnail(cache_path, str(e))\n        return str(cache_path)\n\ndef create_error_thumbnail(cache_path, error_message):\n    \"\"\"Create a placeholder thumbnail for images that can't be loaded\"\"\"\n    img = Image.new('RGB', (150, 150), color=(200, 200, 200))\n    # Add error message text\n    # ... code to add text to image ...\n    img.save(cache_path, \"JPEG\")\n\ndef clear_thumbnail_cache():\n    \"\"\"Clear the thumbnail cache directory\"\"\"\n    cache_dir = Path(os.path.expanduser(\"~/.image-tagger-renamer/cache/thumbnails/\"))\n    if cache_dir.exists():\n        for file in cache_dir.iterdir():\n            if file.is_file():\n                file.unlink()\n```",
        "testStrategy": "1. Test thumbnail generation for different image formats\n2. Verify thumbnail dimensions are correctly maintained with aspect ratio\n3. Test caching mechanism - verify thumbnails are reused when available\n4. Test cache invalidation when source image changes\n5. Verify error handling for corrupted images\n6. Test with large images to ensure memory efficiency\n7. Performance test with 500+ images to verify speed\n8. Test JP2/JPEG2000 format handling specifically\n9. Verify placeholder generation for unsupported formats",
        "subtasks": []
      },
      {
        "id": "4",
        "title": "Tag Management System",
        "description": "Implement the tag management system for creating, storing, and retrieving tags that persist between sessions.",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "Create tag_manager.py module with the following features:\n1. Load and save tag library to/from ~/.image-tagger-renamer/tags.json\n2. Add new tags functionality\n3. Get full tag list\n4. Tag validation (no duplicates, valid characters)\n5. Track creation and modification timestamps\n6. Initialize with default tags if file doesn't exist\n\nImplementation details:\n```python\nimport json\nimport os\nfrom pathlib import Path\nfrom datetime import datetime\nimport fcntl\nimport re\n\nclass TagManager:\n    def __init__(self):\n        self.config_dir = Path(os.path.expanduser(\"~/.image-tagger-renamer/\"))\n        self.config_dir.mkdir(parents=True, exist_ok=True)\n        self.tags_file = self.config_dir / \"tags.json\"\n        self.default_tags = [\n            \"comics\", \"nancy\", \"sluggo\", \"popart\", \"warhol\", \n            \"fineart\", \"advertising\", \"logos\", \"food\", \"horror\", \"western\"\n        ]\n        self.tags = self.load_tags()\n    \n    def load_tags(self):\n        \"\"\"Load tags from file or create with defaults if not exists\"\"\"\n        if not self.tags_file.exists():\n            # Initialize with defaults\n            tag_data = {\n                \"tags\": self.default_tags,\n                \"created\": datetime.now().isoformat(),\n                \"last_modified\": datetime.now().isoformat(),\n                \"version\": \"1.0.0\"\n            }\n            self._save_tag_data(tag_data)\n            return self.default_tags\n        \n        try:\n            with open(self.tags_file, 'r') as f:\n                tag_data = json.load(f)\n                return tag_data.get(\"tags\", self.default_tags)\n        except (json.JSONDecodeError, IOError):\n            # If file is corrupted, reset to defaults\n            return self.default_tags\n    \n    def _save_tag_data(self, tag_data):\n        \"\"\"Atomic save of tag data with file locking\"\"\"\n        # Create temp file\n        temp_file = self.tags_file.with_suffix('.tmp')\n        \n        try:\n            with open(temp_file, 'w') as f:\n                # Use file lock for atomic write\n                fcntl.flock(f, fcntl.LOCK_EX)\n                json.dump(tag_data, f, indent=2)\n                f.flush()\n                os.fsync(f.fileno())\n            \n            # Atomic rename\n            temp_file.replace(self.tags_file)\n        finally:\n            # Clean up temp file if something went wrong\n            if temp_file.exists():\n                temp_file.unlink(missing_ok=True)\n    \n    def save_tags(self):\n        \"\"\"Save current tags to file\"\"\"\n        tag_data = {\n            \"tags\": self.tags,\n            \"last_modified\": datetime.now().isoformat(),\n            \"version\": \"1.0.0\"\n        }\n        \n        # If file exists, preserve created date\n        if self.tags_file.exists():\n            try:\n                with open(self.tags_file, 'r') as f:\n                    existing_data = json.load(f)\n                    if \"created\" in existing_data:\n                        tag_data[\"created\"] = existing_data[\"created\"]\n            except (json.JSONDecodeError, IOError):\n                tag_data[\"created\"] = datetime.now().isoformat()\n        else:\n            tag_data[\"created\"] = datetime.now().isoformat()\n            \n        self._save_tag_data(tag_data)\n    \n    def add_tag(self, tag):\n        \"\"\"Add a new tag if valid and not duplicate\"\"\"\n        # Validate tag format (alphanumeric, no spaces)\n        if not re.match(r'^[\\w-]+$', tag):\n            return False, \"Tags can only contain letters, numbers, underscores, and hyphens\"\n        \n        # Check for duplicates (case insensitive)\n        if tag.lower() in (t.lower() for t in self.tags):\n            return False, \"Tag already exists\"\n        \n        self.tags.append(tag)\n        self.save_tags()\n        return True, \"Tag added successfully\"\n    \n    def get_all_tags(self):\n        \"\"\"Return all tags\"\"\"\n        return self.tags\n```",
        "testStrategy": "1. Verify default tags are loaded correctly on first run\n2. Test adding new tags and persistence between runs\n3. Verify tag validation rejects invalid formats\n4. Test duplicate tag detection (case insensitive)\n5. Verify atomic file operations with concurrent access\n6. Test file corruption recovery (loading defaults if file corrupted)\n7. Verify timestamp tracking for created and modified dates\n8. Test with empty tag file and recovery behavior",
        "subtasks": []
      },
      {
        "id": "5",
        "title": "Flask Routes and API Endpoints",
        "description": "Implement the Flask routes and API endpoints for the application's backend functionality.",
        "status": "pending",
        "dependencies": [
          "1",
          "2",
          "3",
          "4"
        ],
        "priority": "medium",
        "details": "Create the routes and API endpoints for the application with the following:\n\n1. Main UI route\n2. API endpoints for directory scanning, image listing, thumbnails, tags, and rename operations\n3. Error handling for all routes\n4. JSON responses for API endpoints\n\nImplementation details:\n```python\nfrom flask import Flask, render_template, request, jsonify, send_file, abort\nimport os\nfrom pathlib import Path\nimport logging\n\nfrom models.file_manager import scan_directory, rename_file\nfrom models.tag_manager import TagManager\nfrom thumbnail import generate_thumbnail\n\napp = Flask(__name__)\ntag_manager = TagManager()\n\n# Configure logging\nlogging.basicConfig(filename='~/.image-tagger-renamer/app.log', level=logging.INFO,\n                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@app.route('/')\ndef index():\n    \"\"\"Render the main application UI\"\"\"\n    return render_template('index.html')\n\n@app.route('/api/images')\ndef get_images():\n    \"\"\"Get all images in the specified directory with thumbnails\"\"\"\n    directory = request.args.get('dir')\n    if not directory:\n        return jsonify({'error': 'No directory specified'}), 400\n    \n    try:\n        image_files = scan_directory(directory)\n        images = []\n        \n        for img_path in image_files:\n            try:\n                # Generate thumbnail and get URL\n                thumbnail = generate_thumbnail(img_path)\n                \n                images.append({\n                    'path': str(img_path),\n                    'name': img_path.name,\n                    'thumbnail': f'/api/thumbnail?path={str(thumbnail)}'\n                })\n            except Exception as e:\n                logger.error(f\"Error processing image {img_path}: {str(e)}\")\n        \n        return jsonify({\n            'directory': directory,\n            'count': len(images),\n            'images': images\n        })\n    except Exception as e:\n        logger.error(f\"Error scanning directory {directory}: {str(e)}\")\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/thumbnail')\ndef get_thumbnail():\n    \"\"\"Serve a cached thumbnail\"\"\"\n    path = request.args.get('path')\n    if not path or not os.path.exists(path):\n        abort(404)\n    \n    return send_file(path)\n\n@app.route('/api/tags', methods=['GET'])\ndef get_tags():\n    \"\"\"Get all available tags\"\"\"\n    return jsonify({'tags': tag_manager.get_all_tags()})\n\n@app.route('/api/tags', methods=['POST'])\ndef add_tag():\n    \"\"\"Add a new tag\"\"\"\n    data = request.json\n    if not data or 'tag' not in data:\n        return jsonify({'error': 'No tag specified'}), 400\n    \n    success, message = tag_manager.add_tag(data['tag'])\n    if success:\n        return jsonify({'status': 'success', 'message': message})\n    else:\n        return jsonify({'error': message}), 400\n\n@app.route('/api/rename', methods=['POST'])\ndef rename_images():\n    \"\"\"Rename selected images\"\"\"\n    data = request.json\n    if not data or 'images' not in data or 'tags' not in data:\n        return jsonify({'error': 'Missing required parameters'}), 400\n    \n    images = data['images']\n    tags = data['tags']\n    prefix = data.get('prefix', '')\n    suffix = data.get('suffix', '')\n    \n    results = []\n    for img_path in images:\n        try:\n            new_name, error = rename_file(\n                img_path, \n                Path(img_path).parent,\n                prefix, \n                tags, \n                suffix\n            )\n            \n            results.append({\n                'original': img_path,\n                'new_name': new_name,\n                'success': error is None,\n                'error': error\n            })\n            \n            if error:\n                logger.error(f\"Error renaming {img_path}: {error}\")\n            else:\n                logger.info(f\"Renamed {img_path} to {new_name}\")\n                \n        except Exception as e:\n            logger.error(f\"Exception renaming {img_path}: {str(e)}\")\n            results.append({\n                'original': img_path,\n                'success': False,\n                'error': str(e)\n            })\n    \n    return jsonify({\n        'results': results,\n        'success_count': sum(1 for r in results if r['success']),\n        'error_count': sum(1 for r in results if not r['success'])\n    })\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```",
        "testStrategy": "1. Test each API endpoint with valid and invalid inputs\n2. Verify error responses contain helpful messages\n3. Test directory scanning with various folder structures\n4. Test thumbnail serving with various image formats\n5. Test tag operations (GET and POST)\n6. Test rename operations with different combinations of tags\n7. Test with large batches of images\n8. Verify logging captures all operations\n9. Test error handling for edge cases (permissions, invalid paths)\n10. Verify JSON response format matches expected schema",
        "subtasks": []
      },
      {
        "id": "6",
        "title": "Frontend UI Structure and HTML Templates",
        "description": "Develop the HTML structure and templates for the user interface based on the mockup and PRD specifications.",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "Create the HTML templates for the application with the following features:\n\n1. Main layout with thumbnail grid and control panel\n2. Dark mode by default\n3. Basic responsive design for different screen sizes\n4. Semantic HTML with accessibility support\n\nImplementation details for index.html:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Image Tagger & Renamer</title>\n    <link href=\"https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap\" rel=\"stylesheet\">\n    <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='css/styles.css') }}\">\n</head>\n<body class=\"dark-mode\">\n    <div class=\"container\">\n        <header class=\"app-header\">\n            <h1>Image Tagger & Renamer</h1>\n            <div class=\"directory-display\">\n                <span>Directory:</span>\n                <span id=\"current-directory\" class=\"directory-path\">No folder selected</span>\n            </div>\n        </header>\n        \n        <div class=\"controls-bar\">\n            <button id=\"change-folder\" class=\"btn primary\">Change Folder</button>\n            \n            <div class=\"selection-controls\">\n                <label class=\"toggle-switch\">\n                    <input type=\"checkbox\" id=\"multi-select-toggle\">\n                    <span class=\"toggle-label\">Multi-Select</span>\n                    <span class=\"toggle-slider\"></span>\n                </label>\n                \n                <button id=\"select-all\" class=\"btn secondary\" disabled>Select All</button>\n                <button id=\"clear-selection\" class=\"btn secondary\" disabled>Clear</button>\n                \n                <div class=\"selection-count\">\n                    <span>Selected:</span>\n                    <span id=\"selected-count\">0</span>\n                    <span>/</span>\n                    <span id=\"total-count\">0</span>\n                </div>\n            </div>\n        </div>\n        \n        <main>\n            <div id=\"loading-indicator\" class=\"loading-indicator hidden\">\n                <div class=\"spinner\"></div>\n                <p>Loading images...</p>\n            </div>\n            \n            <div id=\"error-display\" class=\"error-display hidden\">\n                <p class=\"error-message\">Error message goes here</p>\n            </div>\n            \n            <div id=\"image-grid\" class=\"image-grid\">\n                <!-- Images will be loaded here dynamically -->\n            </div>\n            \n            <div id=\"no-images\" class=\"no-images-message hidden\">\n                <p>No images found in the selected directory.</p>\n            </div>\n        </main>\n        \n        <footer class=\"tagging-panel\">\n            <div class=\"input-section\">\n                <div class=\"input-group\">\n                    <label for=\"prefix-input\">Prefix:</label>\n                    <input type=\"text\" id=\"prefix-input\" class=\"text-input\">\n                </div>\n                \n                <div class=\"input-group\">\n                    <label for=\"suffix-input\">Suffix:</label>\n                    <input type=\"text\" id=\"suffix-input\" class=\"text-input\">\n                </div>\n            </div>\n            \n            <div class=\"tag-section\">\n                <h3>Tags:</h3>\n                <div id=\"tag-container\" class=\"tag-container\">\n                    <!-- Tags will be loaded here dynamically -->\n                </div>\n                <button id=\"add-tag-button\" class=\"btn add-tag\">+ Add New Tag</button>\n                <div id=\"add-tag-input-container\" class=\"add-tag-input hidden\">\n                    <input type=\"text\" id=\"new-tag-input\" class=\"text-input\" placeholder=\"New tag name\">\n                    <button id=\"save-tag-button\" class=\"btn primary\">Save</button>\n                    <button id=\"cancel-tag-button\" class=\"btn secondary\">Cancel</button>\n                </div>\n            </div>\n            \n            <div class=\"preview-section\">\n                <h3>Preview:</h3>\n                <div id=\"filename-preview\" class=\"filename-preview\">No files selected</div>\n            </div>\n            \n            <div class=\"rename-section\">\n                <button id=\"rename-button\" class=\"btn primary rename-button\" disabled>Rename Selected Images</button>\n            </div>\n        </footer>\n    </div>\n    \n    <div id=\"folder-select-modal\" class=\"modal hidden\">\n        <div class=\"modal-content\">\n            <h2>Select Folder</h2>\n            <div class=\"folder-input\">\n                <label for=\"folder-path\">Folder Path:</label>\n                <input type=\"text\" id=\"folder-path\" class=\"text-input\" placeholder=\"Enter folder path...\">\n            </div>\n            <div class=\"modal-buttons\">\n                <button id=\"select-folder-button\" class=\"btn primary\">Select</button>\n                <button id=\"cancel-folder-button\" class=\"btn secondary\">Cancel</button>\n            </div>\n        </div>\n    </div>\n    \n    <script src=\"{{ url_for('static', filename='js/app.js') }}\"></script>\n</body>\n</html>\n```",
        "testStrategy": "1. Validate HTML against W3C standards\n2. Test responsive layout at different screen sizes\n3. Verify semantic HTML structure for accessibility\n4. Test keyboard navigation through the interface\n5. Test focus indicators and tabbing order\n6. Verify proper ARIA attributes for interactive elements\n7. Test color contrast for readability\n8. Verify integration with JavaScript functionality\n9. Test template rendering with Flask\n10. Verify dark mode styling is applied correctly",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "CSS Styling and Responsive Design",
        "description": "Implement the CSS styling for the application UI based on the mockup, with dark mode as the default theme.",
        "status": "pending",
        "dependencies": [
          "6"
        ],
        "priority": "medium",
        "details": "Create the CSS for the application with the following features:\n\n1. Dark mode theme as default\n2. Responsive grid layout for thumbnails\n3. Styled components matching the mockup\n4. Focus indicators for accessibility\n5. Loading indicators and animations\n\nImplementation details for styles.css:\n```css\n:root {\n  --primary-color: #0db9f2;\n  --text-primary: #ffffff;\n  --text-secondary: #cccccc;\n  --background-dark: #1a1a1a;\n  --panel-dark: #2a2a2a;\n  --border-dark: #444444;\n  --thumbnail-size: 150px;\n  --thumbnail-gap: 10px;\n  --focus-outline: 2px solid var(--primary-color);\n}\n\n* {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n\nbody {\n  font-family: 'Space Grotesk', sans-serif;\n  color: var(--text-primary);\n  background-color: var(--background-dark);\n  line-height: 1.6;\n}\n\n.dark-mode {\n  --text-primary: #ffffff;\n  --text-secondary: #cccccc;\n  --background-dark: #1a1a1a;\n  --panel-dark: #2a2a2a;\n  --border-dark: #444444;\n}\n\n.container {\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n  max-width: 100%;\n  margin: 0 auto;\n  padding: 0;\n}\n\n/* Header Styles */\n.app-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1rem 1.5rem;\n  background-color: var(--panel-dark);\n  border-bottom: 1px solid var(--border-dark);\n}\n\n.app-header h1 {\n  font-size: 1.5rem;\n  font-weight: 600;\n}\n\n.directory-display {\n  font",
        "subtasks": [],
        "testStrategy": ""
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-19T16:57:21.844Z",
      "taskCount": 7,
      "completedCount": 1,
      "tags": [
        "renamer"
      ]
    }
  }
}